<?xml version="1.0"?>
<doc>
<assembly>
<name>
fpeff1
</name>
</assembly>
<members>
<member name="T:fpeff1.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:fpeff1.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:fpeff1.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="T:fpeff1.ArrayExtensions">
 <summary>
 Methods missing from the standard <c>Array</c> implementation
 </summary>
</member>
<member name="M:fpeff1.ArrayExtensions.NewFromPart``1(``0[]@,System.UInt32,System.UInt32)">
 <summary>
 Creates a new array from a part of another array
 </summary>
 <typeparam name="T">Type of the array elements</typeparam>
 <param name="sourceArray">Source array of the data</param>
 <param name="startIndex">Start index of the data to be copied</param>
 <param name="resultLength">Length of the data to be copied</param>
 <returns>New array of type <c>T</c> with the data copied from the source array as specified</returns>
</member>
<member name="M:fpeff1.ArrayExtensions.Concatenate``1(``0[]@,``0[]@)">
 <summary>
 Creates a new array as the concatenation of two arrays
 </summary>
 <typeparam name="T">Type of the array elements</typeparam>
 <param name="firstArray">First array to be concatenated</param>
 <param name="secondArray">First array to be concatenated</param>
 <returns>Concatenation of the first and the second array</returns>
</member>
<member name="T:fpeff1.BigIntegerExtensions">
 <summary>
 Methods missing from the <c>Numerics.BigInteger</c> implementation
 </summary>
</member>
<member name="M:fpeff1.BigIntegerExtensions.ToBigEndianUShortArrayForRadix(System.Numerics.BigInteger@,System.UInt32,System.UInt32)">
 <summary>
 Converts a <c>BigInteger</c> to an <c>UShort</c> array that contains the digits
 of the <c>BigInteger</c> in Big Endian order (i.e. most significant digit first)
 </summary>
 <param name="aNumber">The <c>BigInteger</c> number to be converted</param>
 <param name="radix">The radix of the digits in the result</param>
 <param name="resultSize">The size of the resulting array</param>
 <returns><c>UShort</c> array of the digits in <paramref name="aNumber"/> with radix <paramref name="radix"/></returns>
</member>
<member name="M:fpeff1.BigIntegerExtensions.CorrectModulo(System.Numerics.BigInteger@,System.Numerics.BigInteger@)">
 <summary>
 Calculates correct modulus of two BigIntegers
 </summary>
 <remarks>
 The "normal" <c>mod</c> operator is defined as <c>x mod m = x - m * Floor(x / m)</c>. If the dividend is negative this yields a negative number.
 However, we need a result that is always 0 or positive. To that end, if a negative number is produced by the "normal" <c>mod</c> operator
 the modulus is added to this result, so the the end result is positive or 0. This is a correct modulus, as well.
 </remarks>
 <param name="dividend">Dividend for the <c>mod</c> operator</param>
 <param name="divisor">Divisor for the <c>mod</c> operator</param>
 <returns><paramref name="dividend"/> <c>mod</c> <paramref name="divisor"/>, guaranteed to be not negative</returns>
</member>
<member name="T:fpeff1.ByteExtensions">
 <summary>
 Methods missing from the <c>Byte</c> implementation
 </summary>
</member>
<member name="M:fpeff1.ByteExtensions.NewWithReversedOrder(System.Byte[]@)">
 <summary>
 Creates a new <c>Byte</c> array that is in reverse order of the source array
 </summary>
 <param name="sourceArray">Array whose elements are to be reversed</param>
 <returns>New <c>Byte</c> array in reverse order</returns>
</member>
<member name="M:fpeff1.ByteExtensions.NewWithReversedOrder(System.Byte[]@,System.UInt32)">
 <summary>
 Creates a new <c>Byte</c> array that is in reverse order of the source array with guaranteed minimum length.
 </summary>
 <remarks>
 If <paramref name="minLength"/> is larger than the length of the source array the resulting array is padded to the left
 (with the lower indices) with <c>\&amp;H00</c> bytes.
 </remarks>
 <param name="sourceArray">Array whose elements are to be reversed</param>
 <param name="minLength">Minimum guaranteed length of the result</param>
 <returns>New <c>Byte</c> array in reverse order with guaranteed minimum length</returns>
</member>
<member name="M:fpeff1.ByteExtensions.ReverseWithUnsignedExtension(System.Byte[]@,System.UInt32)">
 <summary>
 Creates a new <c>Byte</c> array with the elements in reverse order of the
 <paramref name="sourceArray"/> and adds a <c>&amp;H00</c> <c>Byte</c> at the element
 with the highest index to guarantee that a BigInteger that is instantiated from
 the resulting <c>Byte</c> array is a positive number.
 </summary>
 <param name="sourceArray">Source Byte array</param>
 <param name="resultLength">Length of the resulting Byte array</param>
 <returns>New <c>Byte</c> array with reversed elements and an additional <c>&amp;H00</c> byte at the highest index. Note that the result has one more element than specified by <paramref name="resultLength"/></returns>
</member>
<member name="M:fpeff1.ByteExtensions.XorValues(System.Byte[]@,System.Byte[]@)">
 <summary>
 Creates a new <c>Byte</c> array as the XOR-ed values of two <c>Byte</c> arrays.
 </summary>
 <remarks>
 Note that the result has the same size as the first array. If the second array is shorter than
 the first array, elements with higher indices than the second array are simply copied.
 If the second array is larger, only as many elements, as are in the first array will be used.
 </remarks>
 <param name="firstArray">First <c>Byte</c> array</param>
 <param name="secondArray">Second <c>Byte</c> array</param>
 <returns>New <c>Byte</c> array with the XOR-ed values of the parameter elements</returns>
</member>
<member name="M:fpeff1.ByteExtensions.XorValues(System.Byte[]@,System.Byte[]@,System.UInt32)">
 <summary>
 Creates a new <c>Byte</c> array as the XOR-ed values of two <c>Byte</c> arrays where the elements in the
 second array are used beginning from <paramref name="secondArrayStartIndex"/>.
 </summary>
 <remarks>
 Note that the result has the same size as the first array. If the second array is shorter than
 the first array elements, with higher indices than the second array are simply copied.
 If the second array starting from <paramref name="secondArrayStartIndex"/> is larger, 
 only as many elements, as are in the first array will be used.
 </remarks>
 <param name="firstArray">First <c>Byte</c> array</param>
 <param name="secondArray">Second <c>Byte</c> array</param>
 <param name="secondArrayStartIndex">Start index in the second array</param>
 <returns>New <c>Byte</c> array with the XOR-ed values of the parameter elements</returns>
</member>
<member name="T:fpeff1.FF1">
 <summary>
 Implements the FF1 algorithm as specified in NIST Special Publication 800-38G (March 2016)
 </summary>
 <remarks>
 Copyright 2017, DB Systel GmbH
 
 Redistribution and use in source and binary forms, with or without modification, are permitted provided
 that the following conditions are met
 
 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 
 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and 
 the following disclaimer in the documentation and/or other materials provided with the distribution.
 
 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
 derived from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 
 BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY And FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT Of SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT Of THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY Of SUCH DAMAGE.

 Author: Frank Schwab, DB Systel GmbH
 Version: 1.0.0
 History:
    2017-04-24 Created.
    
 Usage:
 <code>
      Dim sourceText() As UShort = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
      Dim tweak() As Byte = {&amp;H39, &amp;H38, &amp;H37, &amp;H36, &amp;H35, &amp;H34, &amp;H33, &amp;H32, &amp;H31, &amp;H30}
      Dim key() As Byte = {&amp;H2B, &amp;H7E, &amp;H15, &amp;H16, &amp;H28, &amp;HAE, &amp;HD2, &amp;HA6, &amp;HAB, &amp;HF7, &amp;H15, &amp;H88, &amp;H9, &amp;HCF, &amp;H4F, &amp;H3C}
      
      Dim encryptedData() As UShort
      
      encryptedData = FF1.encrypt(sourceText, 10, key, tweak)

      Dim decryptedData() As UShort
      
      decryptedData = FF1.encrypt(encryptedData, 10, key, tweak)
 </code>
 </remarks>
</member>
<member name="M:fpeff1.FF1.pseudoRandomFunction(System.Security.Cryptography.ICryptoTransform@,System.Byte[]@)">
 <summary>
 Pseudo random function as specified in FF1, algorithm 6
 </summary>
 <param name="encryptor">AES-ECB-NoPadding encryptor with key already set</param>
 <param name="byteArray">Data to be used in generating the PRF value</param>
 <returns>Pseudo random number</returns>
</member>
<member name="M:fpeff1.FF1.initializeP(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
 <summary>
 Sets the constant byte array P as specified in FF1, algorithm 7 and algorithm 8
 </summary>
 <param name="sourceLength">Length of the source input</param>
 <param name="radix">Radix of the numbers</param>
 <param name="leftLength">Length of the left part of the source</param>
 <param name="tweakLength">Length of the tweak</param>
 <returns>The (from there on) constant array P</returns>
</member>
<member name="M:fpeff1.FF1.initializeQ(System.Byte[]@,System.UInt32,System.UInt32)">
 <summary>
 Initializes the constant part of array Q as specified in FF1, algorithm 7 and algorithm 8
 </summary>
 <param name="tweak">The tweak byte array</param>
 <param name="tweakLength">Length of the tweak byte array</param>
 <param name="maxPartNumberByteLength">Maximum byte length of the binary numbers used in the calculation parts</param>
 <returns>The array Q with the constant parts set</returns>
</member>
<member name="M:fpeff1.FF1.complementQ(System.Byte[]@,System.Byte,System.Numerics.BigInteger@,System.UInt32)">
 <summary>
 Complement array Q with round data
 </summary>
 <param name="q">Q array to be complemented</param>
 <param name="roundNumber">Round number</param>
 <param name="partAsBigInteger">Part that is used in the calculation</param>
 <param name="maxPartNumberByteLength">Maximum byte length of the binary numbers used in the calculation parts</param>
</member>
<member name="M:fpeff1.FF1.constructS(System.Byte[]@,System.Byte[]@,System.UInt32,System.Security.Cryptography.ICryptoTransform@)">
 <summary>
 Construct array S as specified in FF1, algorithm 7 and algorithm 8
 </summary>
 <param name="s">S array to be filled with data (Allocated and reused in the calling method for efficiency)</param>
 <param name="r">Output of the pseudo random function</param>
 <param name="blockCount">No. of blocks to be processed</param>
 <param name="encryptor">AES-ECB-NoPadding encryptor with key already set</param>
</member>
<member name="M:fpeff1.FF1.setUpMachinery(System.UInt16[]@,System.UInt16@,System.Byte[]@,System.Byte[]@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.Numerics.BigInteger@,System.Numerics.BigInteger@,System.UInt16[]@,System.UInt16[]@,System.UInt32@,System.UInt32@,System.UInt32@,System.Security.Cryptography.AesManaged@,System.Security.Cryptography.ICryptoTransform@,System.Byte[]@,System.Byte[]@)">
 <summary>
 Common initialization of the encryption/decryption machinery
 </summary>
 <param name="source">Input: Source of the encryption/decryption</param>
 <param name="radix">Input: Radix of the numbers in the source array</param>
 <param name="encryptionKey">Input: Encryption key to be used</param>
 <param name="tweak">Input: Tweak to be used</param>
 <param name="sourceLength">Output: Length of the Source array</param>
 <param name="tweakLength">Output: Length of the Tweak array</param>
 <param name="leftLength">Output: Length of the left part of the source</param>
 <param name="rightLength">Output: Length of the right part of the source</param>
 <param name="radixToTheLeftSize">Output: The radix power to the leftSize</param>
 <param name="radixToTheRightSize">Output: The radix power to the rightSize</param>
 <param name="leftPart">Output: Left part of the source</param>
 <param name="rightPart">Output: Right part of the source</param>
 <param name="maxPartNumberByteLength">Output: Maximum length of a binary number of one part in bytes</param>
 <param name="feistelRoundOutputLength">Output: Number of bytes for arrays used in Feistel round calculations</param>
 <param name="blockCount">Output: Number of blocks used in Feistel round calculations</param>
 <param name="aesCipher">Output: AES-CBC-NoPadding cipher</param>
 <param name="encryptor">Output: AES-ECB-NoPadding encryptor with key already set</param>
 <param name="p">Output: Array P as specified in FF1, algorithm 7 and algorithm 8</param>
 <param name="q">Output: Array P as specified in FF1, algorithm 7 and algorithm 8</param>
</member>
<member name="M:fpeff1.FF1.calculateY(System.Byte[]@,System.Byte[]@,System.Byte[]@,System.Byte,System.UInt16,System.UInt16[]@,System.UInt32,System.UInt32,System.UInt32,System.Security.Cryptography.ICryptoTransform@)">
 <summary>
 Calculates the binary integer y as specified in FF1 algorithms 7 and 8
 </summary>
 <param name="p">P array as specfied in FF1 algorithms 7 and 8</param>
 <param name="q">Q array as specfied in FF1 algorithms 7 and 8</param>
 <param name="s">S array as specfied in FF1 algorithms 7 and 8</param>
 <param name="roundNumber">Round number</param>
 <param name="radix">Radix of the numbers in the source array</param>
 <param name="part">Left or right part of calculation</param>
 <param name="maxPartNumberByteLength">Maximum length of a binary number of one part in bytes</param>
 <param name="blockCount">Number of blocks used in Feistel round calculations</param>
 <param name="feistelRoundOutputLength">Number of bytes for arrays used in Feistel round calculations</param>
 <param name="encryptor">AES-ECB-NoPadding encryptor with key already set</param>
 <returns>The number y as specfied in FF1 algorithms 7 and 8</returns>
</member>
<member name="M:fpeff1.FF1.checkParameters(System.UInt16[]@,System.UInt32@,System.Byte[]@,System.Byte[]@)">
 <summary>
 Check encrypt/decrypt methods parameters
 </summary>
 <param name="source">Source array</param>
 <param name="radix">Radix of the numbers in the source array</param>
</member>
<member name="M:fpeff1.FF1.encrypt(System.UInt16[]@,System.UInt32@,System.Byte[]@,System.Byte[]@)">
 <summary>
 Encrypt data with the FF1 Format-Preserving cipher
 </summary>
 <param name="source">Clear data to be encrypted</param>
 <param name="radix">Radix of the numbers in source</param>
 <param name="encryptionKey">Encryption key</param>
 <param name="tweak">Tweak</param>
 <returns>Encrypted data</returns>
</member>
<member name="M:fpeff1.FF1.decrypt(System.UInt16[]@,System.UInt32@,System.Byte[]@,System.Byte[]@)">
 <summary>
 Decrypt data with the FF1 Format-Preserving cipher
 </summary>
 <param name="source">Encrypted data to be decrypted</param>
 <param name="radix">Radix of the numbers in source</param>
 <param name="decryptionKey">Decryption key</param>
 <param name="tweak">Tweak</param>
 <returns>Decrypted data</returns>
</member>
<member name="T:fpeff1.fpeff1">
 <summary>
 Simple demonstration program for FF1 encryption/decryption
 </summary>
 <remarks>
 Copyright 2017, DB Systel GmbH
 
 Redistribution and use in source and binary forms, with or without modification, are permitted provided
 that the following conditions are met
 
 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 
 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and 
 the following disclaimer in the documentation and/or other materials provided with the distribution.
 
 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
 derived from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 
 BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY And FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT Of SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT Of THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY Of SUCH DAMAGE.

 Author: Frank Schwab
 Version: 1.0.0
 History:
    2017-04-24  Created
 </remarks>
</member>
<member name="M:fpeff1.fpeff1.tryProcessUShort(System.String@,System.UInt16[]@,System.UInt32)">
 <summary>
 Tries to convert a string to an UShort number and put out error message on console if that is not possible
 </summary>
 <param name="aNumberText">The text to convert</param>
 <param name="destinationArray">The array in which to place the value</param>
 <param name="arrayIndex">The index of the array element that receives the value</param>
 <returns><c>True</c>, if conversion succedded, <c>False</c>, if not</returns>
</member>
<member name="M:fpeff1.fpeff1.commaSeparatedListToUShortArray(System.String@,System.UInt16[]@)">
 <summary>
 Converts a comma-separated list of numbers to an array of UShorts
 </summary>
 <param name="text">Comma-separated list</param>
 <param name="destinationArray">Array that receives the converted numbers</param>
 <returns><c>True</c>, if conversion succedded, <c>False</c>, if not</returns>
</member>
<member name="M:fpeff1.fpeff1.hexTextToByteArray(System.String@,System.Byte[]@)">
 <summary>
 Converts a string of hexadecimal digits to a <c>Byte</c> array
 </summary>
 <param name="text">String of hexadecimal digits</param>
 <param name="destinationArray">Array that receives the converted numbers</param>
 <returns><c>True</c>, if conversion succedded, <c>False</c>, if not</returns>
</member>
<member name="M:fpeff1.fpeff1.showUsage">
 <summary>
 Shows the usage of the program on the console
 </summary>
</member>
<member name="M:fpeff1.fpeff1.simpleCommandLineParser(System.String[]@,System.Boolean@,System.UInt16[]@,System.UInt32@,System.Byte[]@,System.Byte[]@)">
 <summary>
 Parses the command line
 </summary>
 <remarks>
 It is really a shame that MS does not have such a parser in the .Net libs
 </remarks>
</member>
<member name="M:fpeff1.fpeff1.Main(System.String[])">
 <summary>
 Simple command line interface to call FF1.encrypt/.decrypt
 </summary>
 <param name="commandLineArguments">Parameters. See usage</param>
 <returns><c>0</c> if encryption/decryption was successful, <c>1</c>, if a parameter was in error</returns>
</member>
<member name="T:fpeff1.UIntegerExtensions">
 <summary>
 Methods missing from the standard <c>UInteger</c> implementation
 </summary>
</member>
<member name="M:fpeff1.UIntegerExtensions.GetBigEndianBytes(System.UInt32@)">
 <summary>
 Gets bytes of the <c>UInteger</c> in Big Endian order
 </summary>
 <param name="fromInteger">Integer to be converted</param>
 <returns>Bytes of <paramref name="fromInteger"/> in Big Endian order (2 Bytes)</returns>
</member>
<member name="M:fpeff1.UIntegerExtensions.GetBigEndianBytes(System.UInt32@,System.UInt32)">
 <summary>
 Gets bytes of the <c>UInteger</c> in Big Endian order
 </summary>
 <remarks>
 This method always yields a result with a specified length, even if the
 "normal" result would be shorter, or longer. If the <paramref name="resultLength"/> is larger
 than the "normal" result the result is padded to the left with <c>&amp;H00</c> bytes.
 </remarks>
 <param name="fromInteger">Integer to be converted</param>
 <param name="resultLength">Result length</param>
 <returns>Bytes of <paramref name="fromInteger"/> in Big Endian order with length <paramref name="resultLength"/></returns>
</member>
<member name="T:fpeff1.UShortExtensions">
 <summary>
 Methods missing from the <c>UShort</c> implementation
 </summary>
</member>
<member name="M:fpeff1.UShortExtensions.XorValues(System.UInt16[]@,System.UInt16[]@)">
 <summary>
 Creates a new <c>UShort</c> array as the XOR-ed values of two <c>UShort</c> arrays.
 </summary>
 <remarks>
 Note that the result has the same size as the first array. If the second array is shorter than
 the first array elements, with higher indices than the second array are simply copied.
 If the second array is larger, only as many elements, as are in the first array will be used.
 </remarks>
 <param name="firstArray">First <c>UShort</c> array</param>
 <param name="secondArray">Second <c>UShort</c> array</param>
 <returns>New <c>UShort</c> array with the XOR-ed values of the parameter elements</returns>
</member>
<member name="M:fpeff1.UShortExtensions.XorValues(System.UInt16[]@,System.UInt16[]@,System.UInt32)">
 <summary>
 Creates a new <c>UShort</c> array as the XOR-ed values of two <c>UShort</c> arrays where the elements in the
 second array are used beginning from <paramref name="secondArrayStartIndex"/>.
 </summary>
 <remarks>
 Note that the result has the same size as the first array. If the second array is shorter than
 the first array elements, with higher indices than the second array are simply copied.
 If the second array starting from <paramref name="secondArrayStartIndex"/> is larger, 
 only as many elements, as are in the first array will be used.
 </remarks>
 <param name="firstArray">First <c>UShort</c> array</param>
 <param name="secondArray">Second <c>UShort</c> array</param>
 <param name="secondArrayStartIndex">Start index in the second array</param>
 <returns>New <c>UShort</c> array with the XOR-ed values of the parameter elements</returns>
</member>
<member name="M:fpeff1.UShortExtensions.ToBigIntegerWithRadix(System.UInt16[]@,System.UInt32)">
 <summary>
 Converts an <c>UShort</c> array to a <c>BigInteger</c> where the array's elements represent
 numbers to the radix <paramref name="radix"/>.
 </summary>
 <remarks>
 For performance reasons here is no check whether the array elements are valid "digits".
 </remarks>
 <param name="anUShortArray">Array with the "digits" in Big Endian order (i.e. the most significant digit first)</param>
 <param name="radix">Radix of the numbers in the array</param>
 <returns><c>BigInteger</c> that is created from the "digits" in the <c>UShort</c> array</returns>
</member>
<member name="M:fpeff1.UShortExtensions.NewFromPartWithCheckForRadix(System.UInt16[]@,System.UInt32,System.UInt32,System.UInt32)">
 <summary>
 Creates a new <c>UShort</c> array from a part of another <c>UShort</c> array and checks each "digit" of the source
 for validity to radix <paramref name="radix"/>
 </summary>
 <param name="sourceArray">Source array</param>
 <param name="startIndex">Start index of the data to be copied</param>
 <param name="radix">Radix of the digits</param>
 <returns>New <c>UShort</c> array with the data copied from the source array as specified and each "digit" guaranteed to be valid</returns>
</member>
<member name="M:fpeff1.UShortExtensions.GetBigEndianBytes(System.UInt16@)">
 <summary>
 Gets bytes of the <c>UShort</c> in Big Endian order
 </summary>
 <param name="fromInteger">Integer to be converted</param>
 <returns>Bytes of <paramref name="fromInteger"/> in Big Endian order (2 Bytes)</returns>
</member>
<member name="M:fpeff1.UShortExtensions.GetBigEndianBytes(System.UInt16@,System.UInt32)">
 <summary>
 Gets bytes of the <c>UShort</c> in Big Endian order
 </summary>
 <remarks>
 This method always yields a result with a specified length, even if the
 "normal" result would be shorter, or longer. If the <paramref name="resultLength"/> is larger
 than the "normal" result the result is padded to the left with <c>&amp;H00</c> bytes.
 </remarks>
 <param name="fromInteger">Integer to be converted</param>
 <param name="resultLength">Result length</param>
 <returns>Bytes of <paramref name="fromInteger"/> in Big Endian order with length <paramref name="resultLength"/></returns>
</member>
</members>
</doc>
